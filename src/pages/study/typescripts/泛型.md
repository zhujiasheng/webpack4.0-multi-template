### 泛型基本使用
```
function calc2<T, P>(first: T, second: P) {
  let result

  if (typeof first == 'number' && typeof second == 'number') {
    result = first + second
  }

  return result
}
```

#### 对象中使用泛型
```
interface p1 {
  name: string
}

class person<T extends p1> {
  constructor(private mess: T[]) {
    this.mess = mess
  }
  getMess(index: number): T {
    return this.mess[index]
  }
  addMess(value: T): void {
    this.mess.push(value)
  }
  getAllMess(): T[] {
    return this.mess
  }
}

let first = new person([{ name: 'rise' }])
console.log(first.getAllMess())

first.addMess({ name: 'aa' })
first.addMess({ name: 'aa' })
console.log(first.getAllMess())

console.log(first.getMess(2))
```
#### 泛型继承接口
```

//泛型继承接口
interface gril {
  name: string
  age: number
  sex?: string
  getInfor1(): string
}

interface boy {
  getInfor2(): object
}

function calc3<T extends gril | boy>(first: T, second: T) {
  return {
    first,
    second,
  }
}

calc3(
  {
    name: 'rise',
    age: 12,
    sex: 'boy',
    getInfor1() {
      return ''
    },
    getInfor2() {
      return {}
    },
  },
  {
    name: 'rise',
    age: 12,
    sex: 'gril',
    getInfor2() {
      return {}
    },
    getInfor1() {
      return ''
    },
  },
)
```