#### 总结
```
联合类型 就是在接受数据做下类型数据判断
如果存在返回 定义了几种类型 根据判断返回对应的类型
```

#### 类型断言
```
interface Waiter {
  anjiao: boolean
  say: (a: string, b: string) => string
}

interface Teacher {
  anjiao: boolean
  skill: (a: number) => number
}

//类型断言
function getInfo(animal: Waiter | Teacher) {
  if (animal.anjiao) {
    let res = (animal as Waiter).say('js-', 'rise')
    console.log(res)
  } else {
    let res = (animal as Teacher).skill(100)
    console.log(res)
  }
}

console.log(
  getInfo({
    anjiao: false,
    say: (a, b) => {
      return a + '-' + b
    },
    skill: a => {
      return a
    },
  }),
)
```

#### 类型保护-in 语法
```
function getInfo(animal: Waiter | Teacher) {
  if ('say' in animal) {
    let res = animal.say('js-', 'rise')
    console.log(res)
  } else {
    let res = (animal as Teacher).skill(100)
    console.log(res)
  }
}
```

#### typeof
```
function calc(a: string | number, b: string | number) {
  if (typeof a === 'number' && typeof b === 'number') {
    return a + b
  }
  return `${a}-${b}`
}

calc(1, 2)
```

#### instanceof
```
interface obj {
  count: number
}

function calc(first: obj | string, second: obj | string) {
  if (first instanceof Object && second instanceof Object) {
    return first.count + second.count
  }
  return null
}
calc({ count: 1 }, { count: 2 })
```

#### Array.isArray
```
type list = any[]

function calcList(value: list | string) {
  if (Array.isArray(value)) {
    let rr = value.map(it => it * 2)
    return rr
  }
  return ''
}

console.log(calcList([1, '2', 3]))
```